import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-input", "--sequence", required=True, type=str, help="Enter your RNA sequence or fasta file here!")
parser.add_argument("-mll", "--minloop", default=2, type=int, help="Modify the minimal loop length.")
parser.add_argument("-file", "--file", choices=['True', 'False'], default='False', help="Set True to get .dp file as output.")

a = parser.parse_args()


# create sequence from fasta file

def readfromfasta(file):
    file = open(a.sequence, 'r')
    rawseq = str()
    for line in file:
        if line.startswith('>'):
            pass
        else:
            rawseq = rawseq + line
    fastaseq = rawseq.replace(" ", "").replace("\n", "")
    file.close()
    return fastaseq


# initialise matrix

def init(m):
    matrix = list(list(0 for x in range(m)) for x in range(m))
    return (matrix)


# show matrix

def show(matrix, m):
    for i in range(m):
        for j in range(m):
            print("{:4d}".format(matrix[i][j]), end='')
        print()


# scoring 'matrix'


def createscoringmatrix(file):
    f = open(file, 'r')
    for line in f:
        if line.startswith('#'):
            pass
        else:
            line = line.replace(' ', "")
            line_list = [x for x in line]
            pairs.update({(line_list[0], line_list[1]): int(line_list[2]),})
    return pairs


# filling

def fill(matrix, m, pairs):
    for n in range(2, m):
        for j in range(n, m):
            i = j - n
            matrix[i][j] = max(matrix[i][j-1],              # unpaired
                               matrix[i+1][j],              # unpaired
                               matrix[i+1][j-1] + pairs[seq[i], seq[j]],     # paired
                               max(
                                   [(matrix[i][k] + matrix[k+1][j] * pairs[seq[k], seq[j]]) for k in range(i, j)]     # bifurkation
                               )
            )
    return(matrix)


# traceback

def traceback(i, j):
    if i + minloop < j:
        if matrix[i][j] == matrix[i+1][j]:                  # unpaired
            return traceback(i+1, j)
        elif matrix[i][j] == matrix[i][j-1]:  # unpaired
            return traceback(i, j-1)
        elif matrix[i][j] == (matrix[i + 1][j - 1] + pairs[seq[i], seq[j]]):  # paired
            dotbracket[i] = '('
            dotbracket[j] = ')'
            return traceback(i + 1, j - 1)
        else:                                               # bifurkation
            for k in range(i+1, j-1):
                if matrix[i][j] == matrix[i][k] + matrix[k+1][j]:
                    return traceback(i, k), traceback(k+1, j)
    return dotbracket


# calculate binding energy of the structure

def calculateenergy(dotbracket):
    AU = 0
    GC = 0
    x = 0
    Energy_AU = -1.9
    Energy_GC = -2.9
    for character in dotbracket:
        if character == '(':
            y = dotbracket.index(character, x)
            if seqlist[y] == 'A' or 'U':
                AU = AU + 1
            else:
                GC = GC + 1
            x = dotbracket.index(character, x ) + 1
        else:
             pass
    Energy = (AU*Energy_AU)+(GC*Energy_GC)
    print("The binding energy of this structure is about", Energy, "kcal/mol.")
    return Energy


# write .dp (dot-parentheses) file from current job

def writefile(job, dotbracketstring, seq):
    name = job + '.dp'
    file = open(name, 'w+')
    file.write("#File ")
    file.write(name)
    file.write("\n#This file is generated by Nussinov-Tool (https://github.com/mkohl98/NussinovProject).\n\n")
    file.write(seq)
    file.write("\n")
    file.write(dotbracketstring)
    file.close()
    return





if a.sequence.endswith('.fasta'):
    seq = readfromfasta(a.sequence)
else:
    seq = a.sequence
seq = seq.upper()


valid_characters = set('AUGC')
if set(seq) <= valid_characters:
    seqlist = [x for x in seq]
    m = len(seq)

    minloop = a.minloop  # minimal loop length

    pairs = {}
    createscoringmatrix('scoring_matrix.tab')
    matrix = init(m)
    fill(matrix, m, pairs)
    show(matrix, m)

    dotbracket = ['.' for x in range(m)]  # creating dotbracket annotation
    traceback(0, m-1)
    dotbracketstring = ''.join(str(i) for i in dotbracket)

    print("Dot-Bracket-Annotation:", dotbracketstring)
    calculateenergy(dotbracket)
    if a.file == 'True':
        if a.sequence.endswith('.fasta'):
            job = a.sequence.replace('.fasta','')
        else:
            job = 'sequence'
        writefile(job, dotbracketstring, seq)
    else:
        pass
else:
    print('This is not a valid sequence.')